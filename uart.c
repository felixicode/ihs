#include "uart.h"
#include <reg52.h>
/**********************用户自定义数据区域***************************/
u8 UART_buff[16] = {0};	//设置接收缓冲区
u8 UART_num;						//设置接收数据个数，要比缓冲数组规格小
u8 UART_Rflag;					//uart接收数据完成标志
/********************************************************************
UART初始化函数UART_init()，无形参，无返回值
********************************************************************/
void UART_init()
{
// 115200
	SCON =0x50;
	TH2 = 0xFF;
	TL2 = 0xFD;
	RCAP2H = 0xFF;
	RCAP2L = 0xFD;
	
	TCLK = 1;
	RCLK = 1;
	C_T2 = 0;
	EXEN2 = 0;
	
	TR2 = 1;
	EA = 1;
	ES = 1;
	PS = 1;

	UART_num = 0;
	UART_Rflag = 0;
}
/*******************************************************************
单个字节发送函数UART_SendByte(u8 dat)，有形参data，无返回值
********************************************************************/
void UART_SendByte(u8 dat)
{
	SBUF = dat;
	while(!TI);//等待接收完成
	TI = 0;
}
/*******************************************************************
发送字符串函数UART_SendStr(u8 *s)有形参s为要发送到字符串，无返回值
********************************************************************/
void UART_SendStr(u8 *s)
{
 while(*s!='\0')// \0 表示字符串结束标志，通过检测是否字符串末尾
  {
	UART_SendByte(*s);
	s++;
  }
}
/*******************************************************************
UART的中断服务函数UART_SER (void)，无形参，无返回值
********************************************************************/
void UART_SER (void) interrupt 4 //串行中断服务程序
{
	static unsigned char i = 0;//定义临时变量 
	if(RI)//判断是接收中断产生
	{

		if(!UART_Rflag)//数据接收未完成
		{ 
			RI=0; //清接收标志位		
			UART_buff[i++]=SBUF;//读入缓冲区的值
			if(i >= UART_num) {
				i = 0;
				UART_Rflag = 1;//数据接收完成标志
			}
		}	
	}
//	if(TI)//如果是发送标志位，清零
//	TI=0;
} 
